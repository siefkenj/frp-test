mod sheet;
use sheet::Sheet;
mod expr;
use expr::*;

use anyhow::Result;
use std::io::{self, Write};

fn main() -> Result<()> {
    let mut sheet = Sheet::new_from_vec(vec![
        Expr::Numeric(5),
        Expr::Numeric(10),
        Expr::Expression(vec![
            Operation::Mul(Mul::Ref('a')),
            Operation::Add(Add::Ref('b')),
        ]),
    ]);

    println!("Welcome to Spread!");
    println!("");
    println!("Type a command and press enter to execute it.");
    println!("Type 'quit' to exit Spread.");

    println!("");
    if sheet.len() > 0 {
        println!("Current sheet:");
        println!("{}", sheet);
    }
    loop {
        let mut input = String::new();
        print!("> ");
        io::stdout().flush().unwrap();

        match io::stdin().read_line(&mut input) {
            Ok(_n) => {
                if input == "quit\n" {
                    println!("Goodbye!");
                    break;
                }

                match parse_line(&input) {
                    Some(assign) => {
                        println!("Assigning {} to {}", assign.expr, assign.var);
                        sheet.set(assign.var, assign.expr);
                        print!("{}", sheet);
                    }
                    None => println!("Invalid input"),
                }
            }
            Err(error) => println!("error: {error}"),
        }
    }

    return Ok(());
}

fn parse_line(line: &str) -> Option<Assignment> {
    if let Some(index) = line.find('=') {
        let (var, value) = line.split_at(index);
        let var = var.trim();
        let value = &value[1..].trim(); // Skip the '=' character

        if var.len() == 1 && var.chars().next().unwrap().is_ascii_lowercase() {
            let var_char = var.chars().next().unwrap();
            if value.chars().all(|c| c.is_digit(10)) {
                return Some(Assignment {
                    var: var_char,
                    expr: Expr::Numeric(value.parse::<i32>().unwrap()),
                });
            } else {
                return Some(Assignment {
                    var: var_char,
                    expr: Expr::Expression(parse_expression(value)),
                });
            }
        }
    }
    None
}

/// Parse a string expression like `"*2 +34 *4"` into [Mul{2}, Add{34}, Mul{4}]
///
/// _Generated by Github Copilot_
fn parse_expression(expression: &str) -> Vec<Operation> {
    let mut result = Vec::new();
    let mut current_value = String::new();
    let mut current_operation: Option<char> = None;

    let push_operation =
        |current_operation: Option<char>, current_value: &str, result: &mut Vec<Operation>| {
            if !current_value.is_empty() && current_operation.is_some() {
                result.push(match current_operation {
                    Some('*') => {
                        if current_value.chars().all(|c| c.is_digit(10)) {
                            Operation::Mul(Mul::Val(current_value.parse::<i32>().unwrap()))
                        } else {
                            Operation::Mul(Mul::Ref(current_value.chars().next().unwrap()))
                        }
                    }
                    Some('+') => {
                        if current_value.chars().all(|c| c.is_digit(10)) {
                            Operation::Add(Add::Val(current_value.parse::<i32>().unwrap()))
                        } else {
                            Operation::Add(Add::Ref(current_value.chars().next().unwrap()))
                        }
                    }
                    _ => unreachable!(),
                });
            }
        };

    for c in expression.chars() {
        match c {
            '*' | '+' => {
                push_operation(current_operation, &current_value, &mut result);
                current_value.clear();
                current_operation = Some(c);
            }
            _ if c.is_digit(10) || c.is_ascii_lowercase() => {
                current_value.push(c);
            }
            _ if c.is_whitespace() => {} // Ignore whitespace
            _ => (),
        }
    }

    push_operation(current_operation, &current_value, &mut result);

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_expression_with_numbers() {
        let expression = "*2 +34 *4";
        let result = parse_expression(expression);

        assert_eq!(result.len(), 3);
        match &result[0] {
            Operation::Mul(Mul::Val(val)) => assert_eq!(*val, 2),
            _ => panic!("Expected Mul, got something else."),
        }
        match &result[1] {
            Operation::Add(Add::Val(val)) => assert_eq!(*val, 34),
            _ => panic!("Expected Add, got something else."),
        }
        match &result[2] {
            Operation::Mul(Mul::Val(val)) => assert_eq!(*val, 4),
            _ => panic!("Expected Mul, got something else."),
        }
    }

    #[test]
    fn test_parse_expression_with_letters() {
        let expression = "*2 +a *4";
        let result = parse_expression(expression);

        assert_eq!(result.len(), 3);
        match &result[0] {
            Operation::Mul(Mul::Val(val)) => assert_eq!(*val, 2),
            _ => panic!("Expected Mul, got something else."),
        }
        match &result[1] {
            Operation::Add(Add::Ref(val)) => assert_eq!(*val, 'a'),
            _ => panic!("Expected Add, got something else."),
        }
        match &result[2] {
            Operation::Mul(Mul::Val(val)) => assert_eq!(*val, 4),
            _ => panic!("Expected Mul, got something else."),
        }
    }

    #[test]
    fn test_parse_line() {
        let line = "a = 123";
        let result = parse_line(line);

        dbg!(&result);
        match result {
            Some(expr) => {
                assert_eq!(expr.var, 'a');
                assert_eq!(expr.expr, Expr::Numeric(123));
            }
            _ => panic!("Expected Numeric assignment, got something else."),
        }
    }

    #[test]
    fn test_parse_line_with_expression() {
        let line = "a = *2 +b";
        let result = parse_line(line);

        dbg!(&result);
        assert_eq!(
            result,
            Some(Assignment {
                var: 'a',
                expr: Expr::Expression(vec![
                    Operation::Mul(Mul::Val(2)),
                    Operation::Add(Add::Ref('b'))
                ])
            })
        )
    }
}
